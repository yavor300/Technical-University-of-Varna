#include <graphics.h>

#include <iostream>

using namespace std;
int main() {

  //в задачата се изобразяват две функции в един графичен прозорец с общи скални коефициенти
  // Изобразява се първата функция y1=3*x1^2+10*x1-100 за стойности на x в диапазона -6<=x1<=10.
  //Изобразяват се 40 стойности на функцията в зададения диапазон (n1=40)
  // Добавчме още една функция y2=2*x2^2-8*x2-30 за стойности на x2 в диапазона -2<=x2<=20.
  //Изобразяват се 50 стойности на функцията в зададения диапазон (n2=50)
  //входните данни се получават от известните функции при зададени диапазони на изменение на
  //x1 от x1min до x1max и брой стойности n1,и на x2 от x2min до x2max
  //и брой стойности n2, които трябва да получим от функциите съответно y1 и y2
  double x1min = -6;
  double x1max = 10;
  int n1 = 70;
  int i;
  double x1[n1];
  double y1[n1];
  double x2min = -2;
  double x2max = 20;
  int n2 = 50;
  double x2[n2];
  double y2[n2];
  double xmin;
  double xmax;
  double ymin;
  double ymax;
  int winwidth = 800, winheight = 600; // параметри на прозореца на графичната система
  int Px = 500, Py = 400, Dx = 50, Dy = 40, x0 = 100, y0 = 450; //параметри на графичния прозорец, в който ще
  //се изобразят данните (вътре в прозореца на графичната система)
  //изчисляване на стъпката на изменение на входните данни, необходима за получаване на n1 броя
  //стойности в масива x1
  double dx1 = (x1max - x1min) / (n1 - 1);
  //изчисляване на стъпката на изменение на входните данни, необходима за получаване на n2 броя
  //стойности в масива x2
  double dx2 = (x2max - x2min) / (n2 - 1);

  // попълване на входните масиви x1 и y1 с изчислените данни
  for (i = 0; i < n1; i++) {
    x1[i] = x1min + i * dx1;
    y1[i] = 3 * x1[i] * x1[i] + 10 * x1[i] - 100; //y1=3*x1^2+10*x1-100
  }
  // попълване на входните масиви x2 и y2 с изчислените данни
  for (i = 0; i < n2; i++) {
    x2[i] = x2min + i * dx2;
    y2[i] = 2 * x2[i] * x2[i] - 8 * x2[i] - 30; //y2=2*x2^2-8*x2-30
  }

  // намиране на y1min и y1max
  double y1min = y1[0];
  double y1max = y1[0];
  for (i = 0; i < n1; i++) {
    if (y1[i] < y1min) y1min = y1[i];
    if (y1[i] > y1max) y1max = y1[i];
  }
  // намиране на y2min и y2max
  double y2min = y2[0];
  double y2max = y2[0];
  for (i = 0; i < n2; i++) {
    if (y2[i] < y2min) y2min = y2[i];
    if (y2[i] > y2max) y2max = y2[i];
  }
  // намиране на общи минимуми и максимуми
  xmin = x1min;
  if (x2min < xmin) xmin = x2min;
  xmax = x1max;
  if (x2max > xmax) xmax = x2max;
  ymin = y1min;
  if (y2min < ymin) ymin = y2min;
  ymax = y1max;
  if (y2max > ymax) ymax = y2max;
  //определяне на скалните коефициенти, които са еднакви за двете функции
  double sx = (xmax - xmin) / Px;
  double sy = (ymax - ymin) / Py;
  cout << ymin;
  // инициализация на графичната система чрез отваряне на графичен прозорец със зададен размер
  initwindow(winwidth, winheight);
  //изчертаване на графичния прозорец
  line(x0, y0, x0 + Px, y0); //хоризонтзлнз ос
  line(x0, y0, x0, y0 - Py); //вертикална ос
  int Ip = Px / Dx;
  int Jp = Py / Dy; //брой деления по хоризонталната и вертикалната ос
  //изчертаване и надписване на деленията по хоризонталната ос
  char text[10];
  for (i = 0; i <= Ip; i++) {

    line(x0 + i * Dx, y0, x0 + i * Dx, y0 + 3); //изчертаване на деленията
    gcvt(xmin + i * Dx * sx, 5.2, text); //преобразуване на реалната стойност, съответстваща на
    //делението в символен низ
    settextjustify(1, 2);
    outtextxy(x0 + i * Dx, y0 + 5, text); // извеждане на стойността, съответстваща на делението
  }
  //изчертаване и надписване на деленията по вертикалната ос
  for (i = 0; i <= Jp; i++) {
    line(x0, y0 - i * Dy, x0 - 3, y0 - i * Dy); //изчертаване на деленията
    gcvt(ymin + i * Dy * sy, 5.2, text); //преобразуване на реалната стойност, съответстваща на
    //делението в символен низ
    settextjustify(2, 1);
    outtextxy(x0 - 10, y0 - Dy * i + 5, text); // извеждане на стойността, съответстваща на делението
  }
  //преобразуване на входните дании x1,y1 в координати на пиксели, които се използват за
  //центрове на окръжности с радиус 2 пиксела
  for (i = 0; i < n1; i++) {
    int x1prim = x0 + (x1[i] - xmin) / sx;
    int y1prim = y0 - (y1[i] - ymin) / sy;
    circle(x1prim, y1prim, 2);
  }
  //преобразуване на входните дании x2,y2 в координати на пиксели, които се използват за
  //центрове на окръжности с радиус 2 пиксела
  setcolor(YELLOW);
  for (i = 0; i < n2; i++) {
    int x2prim = x0 + (x2[i] - xmin) / sx;
    int y2prim = y0 - (y2[i] - ymin) / sy;
    circle(x2prim, y2prim, 2);
  }
  //свързване на окръжностите с отсечки и получаване на 2D графика, съответстваща на входните
  //данни x1,y1
  setcolor(WHITE);
  for (i = 0; i < n1 - 1; i++) {
    int xa = x0 + (x1[i] - xmin) / sx;
    int ya = y0 - (y1[i] - ymin) / sy;
    int xb = x0 + (x1[i + 1] - xmin) / sx;
    int yb = y0 - (y1[i + 1] - ymin) / sy;
    line(xa, ya, xb, yb);
  }
  //свързване на окръжностите с отсечки и получаване на 2D графика, съответстваща на входните
  //данни x2,y2
  setcolor(YELLOW);

  for (i = 0; i < n2 - 1; i++) {
    int xa = x0 + (x2[i] - xmin) / sx;
    int ya = y0 - (y2[i] - ymin) / sy;
    int xb = x0 + (x2[i + 1] - xmin) / sx;
    int yb = y0 - (y2[i + 1] - ymin) / sy;
    line(xa, ya, xb, yb);
  }
  getch();
  return 0;
}